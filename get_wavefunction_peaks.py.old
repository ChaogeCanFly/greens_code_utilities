#!/usr/bin/env python2.7

from glob import glob
import numpy as np
import matplotlib.pyplot as plt

import argh

from ep.helpers import get_local_peaks, get_local_minima
from ep.potential import gauss


def get_array(input, L=100, W=1, eps=0.1, abs=True):
    n, m, re, im = np.loadtxt(input, unpack=True)
    xdim = n[-1] + 1
    ydim = m[-1] + 1
    print "xdim, ydim", xdim, ydim
    N, M, RE, IM = [ x.reshape(xdim, ydim, order='C') for x in n, m, re, im ]
    N = N/N.max()*L
    M = M/M.max()*(W + 4.*eps)

    if abs:
        Z = RE**2 + IM**2
    else:
        Z = RE + IM

    return N, M, Z


def main(pphw=50, N=2.5, L=100, W=1, eps=0.1, sigma=0.01, plot=True):
    array_kwargs = {'L': L,
                    'W': W,
                    'eps': eps}
    X, Y, Za = get_array(glob("pic.*.0000.streu.*.ascii")[0], **array_kwargs)
    _, _, Zb = get_array(glob("pic.*.0001.streu.*.ascii")[0], **array_kwargs)
    _, _, P = get_array(glob("pic.potential.*.ascii")[0], **array_kwargs)
    _, _, G = get_array(glob("pic.geometry.*.ascii")[0], **array_kwargs)

    Zma, Zmb, P = [ np.ma.masked_where(1.-G, z) for z in Za, Zb, P]
    P[P < 0.5] = 0.0

    peaks_p, peaks_a, peaks_b = [ get_local_peaks(z, peak_type='minimum') for z in P, Za, Zb ]
    peaks_b[peaks_a == peaks_b] = 0.0
    idx_p, idx_a, idx_b = [ np.where(p) for p in peaks_p, peaks_a, peaks_b ]

    if plot:
        f, (ax1, ax2) = plt.subplots(nrows=2, figsize=(200, 100))
        cmap = plt.cm.jet
        cmap.set_bad('dimgrey', 1)

        scale = 5.
        ax1.pcolormesh(X, Y, scale*Zma, cmap=cmap)
        ax1.scatter(X[idx_b], Y[idx_b], s=1.5e4, c="w", edgecolors=None)
        ax1.scatter(X[idx_p], Y[idx_p], s=1e4, c="k", edgecolors=None)

        ax2.pcolormesh(X, Y, scale*Zmb, cmap=cmap)
        ax2.scatter(X[idx_b], Y[idx_b], s=1.5e4, c="w", edgecolors=None)
        ax2.scatter(X[idx_p], Y[idx_p], s=1e4, c="k", edgecolors=None)

        for ax in (ax1, ax2):
            ax.set_xlim(X.min(), X.max())
            ax.set_ylim(Y.min(), Y.max())

        plt.savefig('wavefunction.jpg', bbox_inches='tight')

    nyout = pphw*N + 1.
    r_nx_pot = int(nyout*L)
    r_ny_pot = int(nyout*W)
    print "r_nx_pot, r_ny_pot", r_nx_pot, r_ny_pot
    x_pot = np.linspace(0, L, r_nx_pot)
    y_pot = np.linspace(0, W, r_ny_pot)
    X_pot, Y_pot = np.meshgrid(x_pot, y_pot)
    Z_pot = np.zeros_like(X_pot)
    for (xn, yn) in zip(X[idx_b].flatten(), Y[idx_b].flatten()):
            Z_pot -= gauss(X_pot, xn, sigma) * gauss(Y_pot, yn, sigma)

    np.savetxt("output_potential.dat",
               zip(range(len(Z_pot.flatten('F'))), Z_pot.flatten('F')))
    print "output_potential.dat written."
    np.save("output_potential.npy", Z_pot)


if __name__ == '__main__':
    argh.dispatch_command(main)
